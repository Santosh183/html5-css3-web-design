--> It's good practice to put styles in in style tag in head however they could be present in body tag or even out of body, html and head tag as 
	well. we should put in head tag because they will get loaded early before elements so that are ready to aplly while element is being rendered. 
	on other hand script tag we should put just before end of body tag because our js code should run only when all elements are loaded.

--> When we write html5 from scratch to tell browser that this is html5 we have to declare it by <html !DOCTYPE>
	<html !DOCTYPE>
	<html>
	.... body, head all things goes here
	</html>

--> html and css are not case sensitive languages. hence elements name are not case ensitive. in css property names are not case sensitives
	however name of classes , ids are case	sensitive.

--> If we do not give any title to html page by default file name is title

--> strong and b both tags makes texts bold but strong tag means emphasis on some text i.e. not only for presentation. ex. we give emphasis
	for particular word while talking as well.
	<b> and <i> are explicit - they specify bold and italic respectively.
	<strong> and <em> are semantic - they specify that the enclosed text should be "strong" or "emphasised" in some way, usually bold and italic, 
	but allow for the actual styling to be controlled via CSS. Hence these are preferred in modern web pages.
	just by appearance i and em both make rext italic where b and strong makes text bold.

--> text-align: justify; means each line has equal length.

--> by default in box model width of element means just width of content. if we give 100px width , 2px border and 10px padding then total width of 
	element become 124px (100 + 10+ 10 + 2 + 2). Sometimes this inbuilt feature could be annoying enough. to get rid of this we have 
	box-sizing: border-box; after applying this property when we say width: 100px, border: 2px and padding: 10px then total width: 100px
	and content width would be 100px - 20px - 4px = 76px.
	if padding + border goes beyond total width given then width of content become 0.

--> if we set margin to right and left to auto it will place element in middle of the screen horizontally. margin: 0 auto;

--> position:absolute for child and position:relative(or any other) to parent make child element to place at lefmost and top most position.
	by applying right,left,top,bottom we can move child element within parent element. child element without top,left etc properties will
	be placed after padding of parent however if we apply any property like left, right etc. then it's positioning start from just after border
	without respecting padding. for position absolute it always moves with respect to parent element which has some position propoerty.
	in case of position: relative it moves with respect to element itself. also in this case it respect padding even after applying left,right etc.

--> When we start with web designing coming each time with new yet stunning layout might not be possible. So though it sounds wrong we may steal
	some pattern or layout from other websites but with some modifications.

--> When we start to build layout of website we have to make hierarchy on web page so that in hierarchy top order should be dedicated to
	content which must be presented first in front of users. Another important thing by functionality draw all rough sketches of all pages and then 
	decide navigation for each of them.

--> When we add css files to any html page by link tag, hierarchy in which they are imported in head of html page does matter. it's just sequential
	css rules. bottom most imported file will override all css rules for earlier imported files.

--> before adding or applying any css to web pages it could be nice idea to reset or normalize css for all element. reset.css contain all 
	css rules which removes all default styles of all element i.e. block element has default maring. Normalize.css has all css rules which ensure that 
	css properties for all browser would be consistent by default.

--> For responsive web design there few main things we need to use extensively. 
	1) All element should be sized in relative units such as percentage
	2) Images should be flexible and should change size in relative units again.
	3) Using media queries for targeting different screen sizes.
	4) we must have to create layout using grid system where we decide layout where number of columns could be anything between 1 to 12.
	   give column appropriate width and make them responsive by using media queries.

--> when we create sections like header, footer etc. instead of using normal div we should use html5 elements like header , footer.
	by those elements search engine exactly know which is header of web page and which one is footer. also it adds readability.

--> vh units stand for viewport height. 100 vh means 100% of viewports height. height: 100vh is often used to make element's height equal to height of viewport.
	similarely vw: viewport width: 100vw.means 100% of viewports width.
	Viewport: It is your device screen.
	Window: It is your browser window. The window can be as big as viewport or smaller.	

--> when we set background-mage for any element by using background-image: url(img/hero.jpg); image size will not fit with element size. tomake that happen we 
	have to apply    background-size: cover; now in order to make image at center of the page we have to apply    background-position: center;

--> We have often seen below code to make any element 
	position: absolute;
    top:50%;
    left:50%;
    transform: translate(-50%,-50%);
	It naturally cone in mind like if we push element from left and top by 50% then it will come at exactly middle of it's parent. taht's true why do we need to
	translate it by -50% then? Actually by moving element from top and left by 50% either by margin or top-left element comes in middle of screen but from that point
	width and height of elements begin from that pixel and then it's width and height make it look like moving little more towards right 
	and bottom. Element would have been exactly at middle of the parent element if middle of child element is at middle of parent.
	but in our case middle of parent has start of child. In order to make middle of child at  midle of parent we need to move child element
	left and top by half of it's size. so we are translating child element by -50%. IMportant thing to note here is -50% used intranslate
	refers to 50% of element itself but when we say 50% for margin or top it's 50% of parent 

--> when we want to write something on the image we can make image look darket by applying linear gradient.
	background-image: linear-gradient(rgba(0,0,0,0.7),rgba(0,0,0,0.7)),url(img/hero.jpg);

--> When we gives font-size in percentage, it would be % of font size of parent element. this holds true for other properties as well. such as 
	line height, letter-spacing etc. but not for padding and margin.
	parent has font-size: 20px, now in child font-size:200% would be equivalent to 40px. It's good habbit to give font size in some pixels 
	to parent most element(html,body etc.) and then give font-size in percentage to all subsequent element in percentage.
	Usually when we have very big heading with larger font size we should reduce it's font weight to make it look nicer.

--> To create animations transition property is important. Along with other properties we need to apply transition for properties we wish to apply.
	ex. border: 1px solid white; 
		background-color:red; 
		transition: border 0.2s, background-color 0.2s;
	means whenever we have to change in border on hover then it will not change instatly instead it wll take 0.2s to do so.
	It add beautiful transition effect.

--> When we say  width:auto;
	width will never exceed the total width of parent element. Maximum width is it's parent width.
	Even if we add border, padding and margin, content of element itself will become smaller in order to give space for border, padding and margin.
	In case if space required for border + padding + margin is greater than total width of parent element then width of content will become zero.
	When we say    width:100%;
	width of content of element will become 100% of parent element and from now if we add border, padding or margin then it will cause child element 
	to exceed parent element's width and it will starts overflowing out of parent element.

--> We can divide whole web page in different sections. we have section tag in HTML5 which can be used to wrap every individual section.

--> we can write comment in html5 by <!-- comments -->

--> In html5 we can insert differnt symbols or characters which we may not able to type from keyboard. ex. $mdash; would make nice longer dash in page.
	there are many such symbols available.

--> We can use selector::after and selector::before for creating some content after any element. ex we want border of just 10px length for element having 
	width 100px. we can say element::after { display:block; margin-top:10px; width:10px; height:2px; background-color:orange}. in this way we can
	give border-radius to even borders.

--> transform:scale(1.15) will zoom element by 15%.

--> When we add css properties with selector and we have to omit some of selectors depending on condition then we have pseudo class :not().
	ex. div:not(div.classname) in this case all divs except given classname will get those styles applied on them.

--> When we set change opacity of element or images it becomes white so we can't add some cool effects. In this case making background black is good way to 
	to get rid of that. 

--> when we need to create some content which is not on keyboard or in form of html element then using ::after or ::before is good solution.
	by content we can create lot of different symbols in whatever size we want.

--> box-shadow has mainly 5 values which are used mostly. there are others as well but those are rarely used.
	ex. box-shadow: R/L T/B blurr spread color;
	R/L may have either positive or negative value. positive value makes shadow moves towards right of element and negative towards left. 
	T/B may have either positive or negative value. positive value makes shadow moves towards bottom of element and negative towards top.
	blurr is again value in pixel like R/L or T/B. this values increase or decrease in this value increase/decrease blurr of shadow.
	spread is amount in pixel aain like other values which decides how much we want to spread shadow. this makes shadow spread to all side.
	 this means T/B and R/L values are addition to this spread and hence if we want shadow of equal amount from all side we should give spread
	 value and make T/B and R/L 0px. 
	Last value is color of the shadow.

--> When designing forms we should always wrap up all form element in form tag. inside form we usually have one submit button 
	which HTML5 explicitly provide us. <input type="submit" value="name to diaplay on button" />
	now after wrapping form elements inside form tag we can use basic validators of html5 like required etc.
	if we click on submit button it will show warning.

--> for label element if we give id of form element in for attribute then after clicking on label focus on will go to that particular element.
	ex. <label for="idname">Name</label>  <input type="text" id="idname">

--> For making website responsive we have some standard breakpoints.
	/* SMARTPHONES PORTRAIT */ : @media only screen and (min-width: 300px) {}

	/* SMARTPHONES LANDSCAPE */ : @media only screen and (min-width: 480px) {}

	/* TABLETS PORTRAIT */ : @media only screen and (min-width: 768px) {}
	
	/* TABLET LANDSCAPE / DESKTOP */ : @media only screen and (min-width: 1024px) {}   
	
	by minimum width css wil get applied once that width is there. however if othr breakpoint is hit then it will change.
	we also can have max-width. which means below that width css will get applied.

--> <meta name="viewport" content ="width=device-width, initial-scale=1.0">   useful meta tag which tell browser few things. 
	width="" tells which width browser should consider for viewport. initial-scale="" tells that at beginning there should not be zoomed screen.
	we can have different kind of info in metatag such as charset to use, keywords to help search engine to search website and so on.
	  <meta charset="UTF-8">
	  <meta name="description" content="Free Web tutorials">
	  <meta name="keywords" content="HTML,CSS,XML,JavaScript">
	  <meta name="author" content="John Doe">
	  <meta name="viewport" content="width=device-width, initial-scale=1.0">

--> While making website responsive genral approach should be inspect web page in browser and then fix distorted or wrong parts one by one 
	using decided breakpoints.

--> Like responsiveness web pages also should look good on all browsers in internet community. However unfortunately by default differen
	browsers treat or render html5 ,css3 and js in different manner. So after testing on different browser we may see some differnces.
	we can target specif browser by adding prefix before css properties.
	Android: -webkit-
	Chrome: -webkit-
	Firefox: -moz-
	Internet Explorer: -ms-
	iOS: -webkit-
	Opera: -o-
	Safari: -webkit-
	ex. -webkit-border-radius: 5px;
	not all properties need prefixes. only some of properties need them like border-radius, transition, transform etc. in order to know which 
	property need it and which don't need there are couple of plugins available for editors. or else we can check it online.

--> To know whether particular css property is supported in different versions of different browsers we have website caniuse.com to check.

--> One of the most famous method to build nice layout using pure css3 is flexbox. In flexbox we have parent element and several child elements.
	we can render them in several different layout we can think of. There are several css properties we should learn if we want to use flexbox.
	again some of properties are applicable for parent element and some of properties are applicable for the child elements. let's learn them one by one.
	
	parent-1:=> display: flex; perhaps this is starting point of play with flexbox. without this we shouldn't even talk of the flexbox.
	
	parent-2:=> flex-direction: row; by default this property has value row. this property can have four different values.
				flex-direction: row; this means all child items inside parent will render in row. from begining of the parent lement.child-1,child-2..
								from start. flex-direction: row-reverse; this means all child items will render in row but in reverse order. now 
								intersting thing to note here is as direction is reverse that means childs will start rendering from end. child-1,child-2..
								from end.      
				flex-direction: column; this means all child items will render in column from start to bottom. child-1,child-2 ... from top to bottom.
				flex-direction: column-reverse; this means all child items will render in column from bottom to start in upward direction. 
								bottom to top. child-1,child-2 ...
	
	parent-3:=> flex-wrap: nowrap; by default this property has value nowrap. this property has three different values. Sometime let's say we have 
				                   too many child items in parent and they can not fit horizontally or vertically in parent (mostly horizontally).
								   In this case we should use this property.
				flex-wrap: nowrap; this means there should not be wrapping at all. all child should stay on same horizontal flow. and create scroll bar if 
				                   childs are overflowing out of parents.
				flex-wrap: wrap; this means extra childs should appear on next row/column in parent if they are overflowing out of parent element.
								 if flex-direction is row they will appear on next row. and if flex direction is column then on next column.
				flex-wrap: wrap-reverse; first of all there would be wrapping means extra childs will appear on another row or column depending
					                     on flex-direction. here difference is end row/column will appear first. ex. if we have 12 child and only 9 can fit
										 in first row then we will have another row/column for remaining 3. but while rendering in browser.
										 first row will contain those last 3 child and second row will contain first 9.
										 ex. c-10 c-11 c-12
										     c-1 c-2 c-3 c-4 c-5 c-6 c-7 c-8 c-9
	
	parent-4:=> flex-flow: val1 val2; this is not exactly the new property of preant element but it's shorthand property for mixing both flex-direction
	                                  and flex-wrap. first value is value for flex-direction and second one for flex-wrap. ex. flex-flow: row wrap.
	
	parent-5:=> justify-content: flex-start; flex-start is default value for this property. this property has 6 different values. this property is important for
	                             positioning childs inside the parent elements.
				justify-content: flex-start; this will poistion all child elements at the begining of the parent. again in case of flex-direction:row-reverse
				                 beginning of flex will opposite to that of flex-direction:row. same applies for column as well.	
				justify-content: flex-end; this will poisition child elements at the end of parent element. again in case of flex-direction:row-reverse
				                 end of flex will opposite to that of flex-direction:row. same applies for column as well.
				justify-content: center; this will position the child element at the vertically or horizaontally middle of parent element depending on it'same
								 flex-direction. it will leave equal amount of space from both side and child elements will appear at center.
				justify-content: space-between; this means first child item will appear at begining and last at end. and in between them there will be equqal 
				                 amount of space left in between all element. however there will be no space before first element and after last element.
				justify-content: space-around; this means first child item will appear at begining and last at end. and in between them there will be equqal 
				                 amount of space left in between all element. also there will be space before first element and after last element. however
								 amount of space before first element and after last element is less than that of space between the element.
				justify-content: space-evenly; this is exactly similar to space-around value of this property. difference is in this case space in between
								 child elements is same as that of space before first element and space after last element. so equal space.
	
	parent-6:=> align-items: stretch; stretch is default value for this property. with justify content property we can position or align items in horizontal
							 scale when flex-direction is row and in vertical scale if flex direction is column. but this property help us align child
							 elements to align them in vertical scale when flex direction is row and in horizontal scale when flex-direction is vertical.
				align-items: stretch; this means child elements will have height equal to parent even if they are smaller. they will acquire all vertical 
				             space except margin of child element and padding of parent element. however if we explicitly give some height to child then 
							 for that particular child given height will get applied.
				align-items: flex-start; this means when flex-direction is horizontal child elements will be placed at start of vertical scale.
				             if parent has heigh 500px and children have 100px then in this case vertically top 100px will be occupied by children.
							 this would be reverse if flex-direction is column then align -item:flex-start will place them horizontally at the beginning.
				align-items: flex-end; this means when flex-direction is horizontal child elements will be placed at end of vertical scale.
				             if parent has heigh 500px and children have 100px then in this case vertically bottom 100px will be occupied by children.
							 this would be reverse if flex-direction is column then align -item:flex-end will place them horizontally at the end.
					         we now can easily sense that if we change flex-direction then whatever justify content do in row same thing align item do when 
							 flex direction is column.
				align-items: center; this means all child items will appear vertically at middle of parent element. if child elements have different
				             heights then vertical middle of parent will resemble to that of vertical middle of all child elements.
				align-items: baseline; this means baseline of child element will resemble with that of baseline of the parent element.
				             baseline is nothing but bottom of text. i.e. line just above which text would have rendered in that particular element.
	
	parent-7=> align-content: stretch; default value for this property is stretch. justify-content and align-items properties make sure to take care of
	                          alignment and positioning of each child elemetn within single row or column depending on flex-direction. Now let's say we 
							  have so many child elements in parent element that after wrapping they form multiple rows or columns depending on flex 
							  direction in this case this property align all rows or columns withing parent element. align group of child elements 
							  in parent element.
			    align-content: stretch; This means that if flex-wrap is causing to make more rows or columns depending flex-direction then all rows/columns
				               will get stretched in equal amount so that they will fit in parents height/width depending on flex-direction.
				align-content: center; this means multiple rows or column will align at center.
				align-content: space-between; there will be equal space between rows or cloumns but there will not be space before first column/row and
				               after last column/row.
				align-content: space-around; this means there will be equal amount of space in between rows/columns. Also there will be space before 
				               first row/column and after last row/column however space after last column/row and before row/column is less compared to 
							   space in between rows/columns.
				align-content: space-evenly; this means there is eqlal space between rows/columns. Also there is same amount of space before first row/column
				               and after last row/column.
				align-content: flex-start; this means all rows/columns will start from begining of parent element without leaving space anywhere.
				align-content: flex-end; this means all rows/columns will start from end of parent element without leaving space anywhere.
	
	child-1=> order:1; by default this property has value 0 which does nothing. This property is used to decide which child should render first.
	                   if we do not give order then all child elements will render in sequence they are present in html. order=1  will make element
					   to appear first even if that element is present as last child element.
	
	Child-2=> flex-grow:2; default value for this property is 1 which dosen't make any difference. depending on number of child sometime they occupy equal space 
	                       in parent contaiiner. but let's say one of child is removed and hence that blank space amount will be divided by all remainig element.
						   so while dividing that space among remainig child elements if child element has property flex-grow:2; this means this element will
						   take 2 times space than other elements. Don't missunderstand that this element will be 2 times bigger than rest elements.
						   if there are 4 child element each of 120 px and parent element has width 480px. now one of child element is removed so ideally.
						   remaiinig space will be equally divided. so width of each 3 child would be 120 + 120/3 = 160. however if one of child has property
						   flex-grow:2 then what will happen is he will take two shares while dividing space. so it will take 60px and remainig element will
						   take 30px each. so new width of all elements will be 180px, 150px and 150px.
			  
	child-3=>flex-shrink:2; default value for this property is again 1 which dosen't make anything. this is exactly same as flex-grow with just opposite 
			                 impact on element. when extra element is added and rest elements have tos shrink in order to accomodate newer one then 
							 one with this property will shrink given number of times compared to other. for understanding full illustration read flex-grow 
							 description.
			  
	child-4=>flex-basis: 200px; default value for this property is auto again which does nothing. As we see in flex-shrink and flex-grow that soome time 
							 child elements get shrink or can expand size if container size is increased. As we know they may gain equal pixels or 
							 loose equal pixels after resizing of container. However initially we can give some child element some initial width.
							 which is nothing but flex-basis. now in future if they grow then again this element can also gain or loose it's size but 
							 only from original given size. 
	
	child-5=> flex: fg fs fb; this is short hand property for combining flex-grow, flex shrink and flex-basis. sequence of values is same as given.
	
	child-6=> align-self;center; this proepry actually override anything given from container by align-item property. again this property can take below values
	                         which are preety similar to align-items. center,flex-end, flex-start, stretch, basline and auto. auto means whatever width
							 element.
				
		
					      
					
	
	
	
	
	
	
	
	
	
	
